"""
Agent - Base AI agent implementation

Core agent class that provides personality, memory, and debate capabilities.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging
import asyncio

logger = logging.getLogger(__name__)


class AgentState(Enum):
    """Agent operational states"""
    IDLE = "idle"
    THINKING = "thinking"
    RESPONDING = "responding"
    VOTING = "voting"
    ERROR = "error"


@dataclass
class Personality:
    """Agent personality configuration"""
    name: str
    archetype: str  # e.g., "pragmatist", "idealist", "skeptic"
    traits: Dict[str, float]  # Trait scores 0.0-1.0
    background: str
    speaking_style: str
    values: List[str]
    biases: List[str] = field(default_factory=list)

    def get_trait(self, trait_name: str, default: float = 0.5) -> float:
        """Get trait value with default"""
        return self.traits.get(trait_name, default)

    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "name": self.name,
            "archetype": self.archetype,
            "traits": self.traits,
            "background": self.background,
            "speaking_style": self.speaking_style,
            "values": self.values,
            "biases": self.biases,
        }


@dataclass
class DebateContext:
    """Context for a debate session"""
    topic: str
    description: str
    perspectives: List[str]
    background_info: Dict[str, Any]
    participants: List[str]
    rules: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.utcnow)


@dataclass
class AgentResponse:
    """Response generated by an agent"""
    agent_id: str
    content: str
    confidence: float
    reasoning: Optional[str] = None
    sources: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "agent_id": self.agent_id,
            "content": self.content,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
            "sources": self.sources,
            "metadata": self.metadata,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class Vote:
    """Vote cast by an agent"""
    agent_id: str
    option: str
    weight: float
    reasoning: str
    confidence: float
    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "agent_id": self.agent_id,
            "option": self.option,
            "weight": self.weight,
            "reasoning": self.reasoning,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat(),
        }


class Agent:
    """
    Base AI agent for council debates

    Provides core functionality for participating in debates including
    response generation, voting, and memory management.
    """

    def __init__(
        self,
        agent_id: str,
        personality: Personality,
        llm_provider: 'LLMProvider',
        memory_manager: Optional['MemoryManager'] = None
    ):
        self.agent_id = agent_id
        self.personality = personality
        self.llm_provider = llm_provider
        self.memory_manager = memory_manager
        self.state = AgentState.IDLE
        self.current_context: Optional[DebateContext] = None
        self.response_history: List[AgentResponse] = []
        self.vote_history: List[Vote] = []
        self.metadata: Dict[str, Any] = {}

    async def initialize(self) -> None:
        """Initialize agent and its components"""
        logger.info(f"Initializing agent {self.agent_id} ({self.personality.name})")

        if self.memory_manager:
            await self.memory_manager.initialize()

        self.state = AgentState.IDLE
        logger.info(f"Agent {self.agent_id} initialized successfully")

    async def set_context(self, context: DebateContext) -> None:
        """Set current debate context"""
        self.current_context = context
        logger.info(
            f"Agent {self.agent_id} context set: {context.topic}"
        )

    async def respond(
        self,
        prompt: str,
        context: Optional[DebateContext] = None
    ) -> AgentResponse:
        """
        Generate response to a prompt

        Args:
            prompt: The prompt or question to respond to
            context: Optional debate context

        Returns:
            AgentResponse with generated content
        """
        self.state = AgentState.THINKING

        try:
            # Use provided context or current context
            debate_context = context or self.current_context

            # Build full prompt with personality and context
            full_prompt = await self._build_prompt(prompt, debate_context)

            # Retrieve relevant memories
            memories = []
            if self.memory_manager:
                memories = await self.memory_manager.retrieve_relevant(
                    prompt, limit=5
                )

            # Add memories to prompt
            if memories:
                memory_context = "\n".join([
                    f"- {m['content']}" for m in memories
                ])
                full_prompt += f"\n\nRelevant context from memory:\n{memory_context}"

            # Generate response
            self.state = AgentState.RESPONDING
            content = await self.llm_provider.generate(
                full_prompt,
                temperature=self._get_temperature(),
                max_tokens=self._get_max_tokens()
            )

            # Calculate confidence based on personality and content
            confidence = self._calculate_confidence(content, prompt)

            # Create response object
            response = AgentResponse(
                agent_id=self.agent_id,
                content=content,
                confidence=confidence,
                reasoning=None,  # Could extract reasoning from content
                metadata={
                    "personality": self.personality.name,
                    "archetype": self.personality.archetype,
                }
            )

            # Store in history and memory
            self.response_history.append(response)
            if self.memory_manager:
                await self.memory_manager.store(
                    content=f"Q: {prompt}\nA: {content}",
                    metadata={"type": "response", "confidence": confidence}
                )

            self.state = AgentState.IDLE
            return response

        except Exception as e:
            logger.error(f"Error generating response: {e}")
            self.state = AgentState.ERROR
            raise

    async def vote(
        self,
        options: List[str],
        context: Optional[DebateContext] = None
    ) -> Vote:
        """
        Cast vote on debate options

        Args:
            options: Available voting options
            context: Optional debate context

        Returns:
            Vote object with selected option and reasoning
        """
        self.state = AgentState.VOTING

        try:
            debate_context = context or self.current_context

            # Build voting prompt
            vote_prompt = await self._build_voting_prompt(options, debate_context)

            # Generate vote decision
            decision = await self.llm_provider.generate(
                vote_prompt,
                temperature=0.3,  # Lower temperature for voting
                max_tokens=500
            )

            # Parse decision (simplified - would need more robust parsing)
            selected_option, reasoning = self._parse_vote_decision(
                decision, options
            )

            # Calculate vote weight based on confidence
            weight = self._calculate_vote_weight(selected_option, reasoning)
            confidence = self._calculate_confidence(reasoning, vote_prompt)

            vote = Vote(
                agent_id=self.agent_id,
                option=selected_option,
                weight=weight,
                reasoning=reasoning,
                confidence=confidence
            )

            # Store in history
            self.vote_history.append(vote)
            if self.memory_manager:
                await self.memory_manager.store(
                    content=f"Voted: {selected_option}\nReasoning: {reasoning}",
                    metadata={"type": "vote", "option": selected_option}
                )

            self.state = AgentState.IDLE
            return vote

        except Exception as e:
            logger.error(f"Error casting vote: {e}")
            self.state = AgentState.ERROR
            raise

    async def _build_prompt(
        self,
        prompt: str,
        context: Optional[DebateContext]
    ) -> str:
        """Build full prompt with personality and context"""
        parts = []

        # Add personality instructions
        parts.append(f"You are {self.personality.name}, {self.personality.background}")
        parts.append(f"Your archetype: {self.personality.archetype}")
        parts.append(f"Speaking style: {self.personality.speaking_style}")
        parts.append(f"Core values: {', '.join(self.personality.values)}")

        # Add key personality traits
        key_traits = sorted(
            self.personality.traits.items(),
            key=lambda x: x[1],
            reverse=True
        )[:3]
        traits_str = ", ".join([f"{k}: {v:.1f}" for k, v in key_traits])
        parts.append(f"Key traits: {traits_str}")

        # Add debate context if available
        if context:
            parts.append(f"\nDebate Topic: {context.topic}")
            parts.append(f"Description: {context.description}")
            if context.perspectives:
                parts.append(f"Perspectives: {', '.join(context.perspectives)}")

        # Add the actual prompt
        parts.append(f"\nPrompt: {prompt}")
        parts.append("\nProvide your response staying true to your personality:")

        return "\n".join(parts)

    async def _build_voting_prompt(
        self,
        options: List[str],
        context: Optional[DebateContext]
    ) -> str:
        """Build voting prompt"""
        parts = []

        parts.append(f"As {self.personality.name}, you must vote on the following:")

        if context:
            parts.append(f"\nTopic: {context.topic}")

        parts.append("\nOptions:")
        for i, option in enumerate(options, 1):
            parts.append(f"{i}. {option}")

        parts.append("\nConsider your values and traits:")
        parts.append(f"Values: {', '.join(self.personality.values)}")

        parts.append("\nSelect the option that best aligns with your values.")
        parts.append("Format: VOTE: [option number]\nREASONING: [your reasoning]")

        return "\n".join(parts)

    def _parse_vote_decision(
        self,
        decision: str,
        options: List[str]
    ) -> tuple[str, str]:
        """Parse LLM voting decision (simplified)"""
        # Simplified parsing - production would be more robust
        lines = decision.split("\n")
        selected = options[0]  # Default
        reasoning = decision

        for line in lines:
            if line.startswith("VOTE:"):
                vote_str = line.replace("VOTE:", "").strip()
                try:
                    idx = int(vote_str) - 1
                    if 0 <= idx < len(options):
                        selected = options[idx]
                except ValueError:
                    # Try to match option text
                    for option in options:
                        if option.lower() in vote_str.lower():
                            selected = option
                            break
            elif line.startswith("REASONING:"):
                reasoning = line.replace("REASONING:", "").strip()

        return selected, reasoning

    def _calculate_confidence(self, content: str, prompt: str) -> float:
        """Calculate confidence score for response"""
        # Simplified confidence calculation
        # Production would use more sophisticated methods
        base_confidence = 0.7

        # Adjust based on personality traits
        if "analytical" in self.personality.traits:
            base_confidence += self.personality.traits["analytical"] * 0.1

        if "confidence" in self.personality.traits:
            base_confidence += self.personality.traits["confidence"] * 0.1

        # Length-based adjustment (very rough)
        if len(content) > 200:
            base_confidence += 0.05

        return min(1.0, max(0.0, base_confidence))

    def _calculate_vote_weight(self, option: str, reasoning: str) -> float:
        """Calculate vote weight based on conviction"""
        # Weight based on personality confidence trait
        base_weight = 1.0

        if "confidence" in self.personality.traits:
            base_weight = 0.5 + (self.personality.traits["confidence"] * 0.5)

        # Adjust based on reasoning length (stronger reasoning = more weight)
        if len(reasoning) > 100:
            base_weight += 0.1

        return min(1.0, base_weight)

    def _get_temperature(self) -> float:
        """Get LLM temperature based on personality"""
        # More creative personalities get higher temperature
        base_temp = 0.7

        if "creativity" in self.personality.traits:
            base_temp = 0.5 + (self.personality.traits["creativity"] * 0.4)

        return base_temp

    def _get_max_tokens(self) -> int:
        """Get max tokens based on personality verbosity"""
        base_tokens = 500

        if "verbosity" in self.personality.traits:
            base_tokens = int(300 + (self.personality.traits["verbosity"] * 500))

        return base_tokens

    async def get_response_history(
        self,
        limit: Optional[int] = None
    ) -> List[AgentResponse]:
        """Get response history"""
        if limit:
            return self.response_history[-limit:]
        return self.response_history.copy()

    async def get_vote_history(
        self,
        limit: Optional[int] = None
    ) -> List[Vote]:
        """Get vote history"""
        if limit:
            return self.vote_history[-limit:]
        return self.vote_history.copy()

    def get_state(self) -> AgentState:
        """Get current agent state"""
        return self.state

    def get_personality(self) -> Personality:
        """Get agent personality"""
        return self.personality

    async def shutdown(self) -> None:
        """Shutdown agent gracefully"""
        logger.info(f"Shutting down agent {self.agent_id}")

        if self.memory_manager:
            await self.memory_manager.close()

        self.state = AgentState.IDLE

    def __repr__(self) -> str:
        return f"Agent({self.agent_id}, {self.personality.name}, {self.state.value})"
