#!/usr/bin/env python3
"""Generate README.md files for all directories missing one."""
from __future__ import annotations

import argparse
import datetime
import os
from pathlib import Path
from typing import Iterable

AI_HANDOFF_HEADER = "<!-- AI-Handoff:START -->\n" \
    "**AI Handoff Context**: Autogenerated directory overview for collaborative continuity.\n" \
    "**Generator**: tools/generate_directory_readmes.py\n" \
    "**Generated**: {timestamp}\n" \
    "<!-- AI-Handoff:END -->\n\n"

AI_HANDOFF_FOOTER = "\n<!-- AI-Handoff:FOOTER-START -->\n" \
    "**Next Steps**: Review contents and update this README with domain-specific knowledge.\n" \
    "<!-- AI-Handoff:FOOTER-END -->\n"

DEFAULT_EXCLUSIONS = {
    ".git",
    "__pycache__",
    "node_modules",
    ".mypy_cache",
    ".pytest_cache",
    ".ruff_cache",
    ".vscode",
    "__snapshots__",
}


def iter_directories(root: Path) -> Iterable[Path]:
    """Yield directories underneath root, including root itself."""
    for current_root, dirnames, _ in os.walk(root):
        current_path = Path(current_root)
        # Skip excluded directories by modifying dirnames in place
        dirnames[:] = [d for d in dirnames if d not in DEFAULT_EXCLUSIONS and not d.startswith('.')]
        yield current_path


def list_children(directory: Path) -> tuple[list[str], list[str]]:
    """Return sorted lists of direct child directories and files."""
    children_dirs: list[str] = []
    children_files: list[str] = []
    for child in sorted(directory.iterdir()):
        if child.name.startswith('.'):
            continue
        if child.is_dir():
            if child.name in DEFAULT_EXCLUSIONS:
                continue
            children_dirs.append(child.name + "/")
        elif child.is_file():
            children_files.append(child.name)
    return children_dirs, children_files


def build_readme_content(directory: Path, repo_root: Path) -> str:
    rel_path = directory.relative_to(repo_root)
    display_path = "/" if rel_path == Path('.') else f"/{rel_path}"  # leading slash for clarity
    timestamp = datetime.datetime.now(datetime.UTC).replace(microsecond=0).isoformat()
    header = AI_HANDOFF_HEADER.format(timestamp=timestamp)
    title = f"# Directory Overview: `{display_path}`\n\n"
    child_dirs, child_files = list_children(directory)
    sections = []
    if child_dirs:
        sections.append("## Subdirectories\n" + "\n".join(f"- `{name}`" for name in child_dirs) + "\n")
    if child_files:
        sections.append("## Files\n" + "\n".join(f"- `{name}`" for name in child_files) + "\n")
    if not sections:
        sections.append("_This directory currently contains no tracked files._\n")
    footer = AI_HANDOFF_FOOTER
    return header + title + "\n".join(sections) + footer


def ensure_readme(directory: Path, repo_root: Path, dry_run: bool = False) -> bool:
    """Create a README.md if missing. Returns True if a file was created."""
    readme_path = directory / "README.md"
    if readme_path.exists():
        return False
    content = build_readme_content(directory, repo_root)
    if dry_run:
        print(f"[DRY RUN] Would create {readme_path}")
        return False
    readme_path.write_text(content, encoding="utf-8")
    return True


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("root", nargs="?", default=Path.cwd(), type=Path, help="Root directory to scan")
    parser.add_argument("--dry-run", action="store_true", help="List directories that would receive a README")
    args = parser.parse_args()

    root = args.root.resolve()
    created = 0
    for directory in iter_directories(root):
        if ensure_readme(directory, root, dry_run=args.dry_run):
            created += 1
    if not args.dry_run:
        print(f"Created {created} README.md files.")
    else:
        print("Dry run complete.")


if __name__ == "__main__":
    main()
